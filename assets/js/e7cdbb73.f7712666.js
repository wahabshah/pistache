(self.webpackChunkpistache_io=self.webpackChunkpistache_io||[]).push([[489],{2509:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return m}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),i=["components"],s={title:"Asynchronous HTTP programming"},l=void 0,c={unversionedId:"asynchronous-http-programming",id:"asynchronous-http-programming",isDocsHomePage:!1,title:"Asynchronous HTTP programming",description:"\x3c!--",source:"@site/docs/asynchronous-http-programming.md",sourceDirName:".",slug:"/asynchronous-http-programming",permalink:"/pistache/docs/asynchronous-http-programming",editUrl:"https://github.com/pistacheio/pistache/edit/master/pistache.io/docs/asynchronous-http-programming.md",version:"current",frontMatter:{title:"Asynchronous HTTP programming"},sidebar:"leftSidebar",next:{title:"Headers",permalink:"/pistache/docs/headers"}},p=[],h={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Interfaces provided by Pistaches are ",(0,o.kt)("em",{parentName:"p"},"asynchronous")," and ",(0,o.kt)("em",{parentName:"p"},"non-blocking"),". Asynchronous programming allows for code to continue executing even if the result of a given call is not available yet. Calls that provide an asynchronous interface are referred to ",(0,o.kt)("em",{parentName:"p"},"asynchronous calls"),"."),(0,o.kt)("p",null,"An example of such a call is the ",(0,o.kt)("inlineCode",{parentName:"p"},"send()")," function provided by the ",(0,o.kt)("inlineCode",{parentName:"p"},"ResponseWriter")," interface. This function returns the number of bytes written to the socket file descriptor associated to the connection. However, instead of returning directly the value to the caller and thus blocking the caller, it wraps the value into a component called a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise"),"."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," is the Pistache\u2019s implementation of the ",(0,o.kt)("a",{parentName:"p",href:"https://promisesaplus.com"},"Promises/A+")," standard available in many JavaScript implementations. Simply put, during an asynchronous call, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," separates the launch of an asynchronous operation from the retrieval of its result. While the asynchronous might still be running, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise<T>")," is directly returned to the caller to retrieve the final result when it becomes available. A so called continuation can be attach to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," to execute a callback when the result becomes available (when the ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," has been resolved or fulfilled)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'auto res = response.send(Http::Code::Ok, "Hello World");\nres.then(\n    [](ssize_t bytes) { std::cout << bytes << " bytes have been sent\\n" },\n    Async::NoExcept\n);\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"then()")," member is used to attach a callback to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise"),". The first argument is a callable that will be called when the ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," has been ",(0,o.kt)("strong",{parentName:"p"},"succesfully")," resolved. If, for some reason, an error occurs during the asynchronous operation, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," can be ",(0,o.kt)("strong",{parentName:"p"},"rejected")," and will then fail. In this case, the second callable will be called. ",(0,o.kt)("inlineCode",{parentName:"p"},"Async::NoExcept")," is a special callback that will call ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/error/terminate"},(0,o.kt)("inlineCode",{parentName:"a"},"std::terminate()"))," if the promise failed. This is the equivalent of the ",(0,o.kt)("inlineCode",{parentName:"p"},"noexcept")," keyword."),(0,o.kt)("p",null,"Other generic callbacks can also be used in this case:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Async::IgnoreException")," will simply ignore the exception and let the program continue"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Async::Throw"),' will "rethrow" the exception up to an eventual promise call-chain. This has the same effect than the ',(0,o.kt)("inlineCode",{parentName:"li"},"throw")," keyword, except that it is suitable for promises")),(0,o.kt)("p",null,"Exceptions in promises callbacks are propagated through an ",(0,o.kt)("inlineCode",{parentName:"p"},"exception_ptr"),". Promises can also be chained together to create a whole asynchronous pipeline:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'auto fetchOp = fetchDatabase();\nfetchOp\n    .then(\n        [](const User& user) { return fetchUserInfo(user); },\n        Async::Throw)\n    .then(\n        [](const UserInfo& info) { std::cout << "User name = " << info.name << \'\\n\'; },\n        [](exception_ptr ptr) { std::cerr << "An exception occured during user retrieval\\n";}\n);\n')),(0,o.kt)("p",null,"Line 5 will propagate the exception if ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchDatabase()")," failed and rejected the promise."))}m.isMDXComponent=!0}}]);