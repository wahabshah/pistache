(self.webpackChunkpistache_io=self.webpackChunkpistache_io||[]).push([[427],{1914:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return d},toc:function(){return l},default:function(){return m}});var n=a(2122),r=a(9756),i=(a(7294),a(3905)),o=["components"],s={title:"Headers"},p=void 0,d={unversionedId:"headers",id:"headers",isDocsHomePage:!1,title:"Headers",description:"\x3c!--",source:"@site/docs/headers.md",sourceDirName:".",slug:"/headers",permalink:"/pistache/docs/headers",editUrl:"https://github.com/pistacheio/pistache/edit/master/pistache.io/docs/headers.md",version:"current",frontMatter:{title:"Headers"},sidebar:"leftSidebar",previous:{title:"Asynchronous HTTP programming",permalink:"/pistache/docs/asynchronous-http-programming"},next:{title:"HTTP handler",permalink:"/pistache/docs/http-handler"}},l=[{value:"Overview",id:"overview",children:[]},{value:"Defining your own header",id:"defining-your-own-header",children:[]},{value:"MIME types",id:"mime-types",children:[]}],c={toc:l};function m(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Inspired by the ",(0,i.kt)("a",{parentName:"p",href:"https://www.rust-lang.org"},"Rust")," eco-system and ",(0,i.kt)("a",{parentName:"p",href:"https://hyper.rs"},"Hyper"),", HTTP headers are represented as ",(0,i.kt)("em",{parentName:"p"},"type-safe")," plain objects. Instead of representing headers as a pair of ",(0,i.kt)("inlineCode",{parentName:"p"},"(key: string, value: value)"),", the choice has been made to represent them as plain objects. This greatly reduces the risk of typo errors that can not catched by the compiler with plain old strings."),(0,i.kt)("p",null,"Instead, objects give the compiler the ability to catch errors directly at compile-time, as the user can not add or request a header through its name: it has to use the whole ",(0,i.kt)("strong",{parentName:"p"},"type"),". Types being enforced at compile-time, it helps reducing common typo errors."),(0,i.kt)("p",null,"With Pistache, each HTTP Header is a class that inherits from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Http::Header")," base class and use the ",(0,i.kt)("inlineCode",{parentName:"p"},"NAME()")," macro to define the name of the header. List of all headers inside an HTTP request or response are stored inside an internal ",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/container/unordered_map"},(0,i.kt)("inlineCode",{parentName:"a"},"std::unordered_map")),", wrapped in an ",(0,i.kt)("inlineCode",{parentName:"p"},"Header::Collection")," class. Invidual headers can be retrieved or added to this object through the whole type of the header:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"auto headers = request.headers();\nauto ct = headers.get<Http::Header::ContentType>();\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"get<H>")," will return a ",(0,i.kt)("inlineCode",{parentName:"p"},"std::shared_ptr<H>")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"H: Header")," (",(0,i.kt)("inlineCode",{parentName:"p"},"H")," inherits from ",(0,i.kt)("inlineCode",{parentName:"p"},"Header"),"). If the header does not exist, ",(0,i.kt)("inlineCode",{parentName:"p"},"get<H>")," will throw an exception. ",(0,i.kt)("inlineCode",{parentName:"p"},"tryGet<H>")," provides a non-throwing alternative that, instead, returns a null pointer."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Built-in headers")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Headers provided by Pistache live in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Http::Header")," namespace"))),(0,i.kt)("h2",{id:"defining-your-own-header"},"Defining your own header"),(0,i.kt)("p",null,"Common headers defined by the HTTP RFC (",(0,i.kt)("a",{parentName:"p",href:"https://pretty-rfc.herokuapp.com/RFC2616"},"RFC2616"),") are already implemented and available. However, some APIs might define extra headers that do not exist in Pistache. To support your own header types, you can define and register your own HTTP Header by first declaring a class that inherits the ",(0,i.kt)("inlineCode",{parentName:"p"},"Http::Header")," class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class XProtocolVersion : public Http::Header {\n};\n")),(0,i.kt)("p",null,"Since every header has a name, the ",(0,i.kt)("inlineCode",{parentName:"p"},"NAME()")," macro must be used to name the header properly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class XProtocolVersion : public Http::Header {\n    NAME("X-Protocol-Version")\n};\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Http::Header")," base class provides two virtual methods that you must override in your own implementation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void parse(const std::string& data);\n")),(0,i.kt)("p",null,"This function is used to parse the header from the string representation. Alternatively, to avoid allocating memory for the string representation, a ",(0,i.kt)("em",{parentName:"p"},"raw")," version can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void parseRaw(const char* str, size_t len);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"str")," will directly point to the header buffer from the raw http stream. The len parameter is the total length of the header's value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void write(std::ostream& stream) const\n")),(0,i.kt)("p",null,"When writing the response back to the client, the ",(0,i.kt)("inlineCode",{parentName:"p"},"write")," function is used to serialize the header into the network buffer."),(0,i.kt)("p",null,"Let\u2019s combine these functions together to finalize the implementation of our previously declared header:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class XProtocolVersion : public Http::Header {\npublic:\n\n    NAME("X-Protocol-Version")\n\n    XProtocolVersion()\n     : minor(-1)\n     , major(-1)\n    { }\n\n    void parse(const std::string& data) {\n        auto pos = data.find(\'.\');\n        if (pos != std::string::npos) {\n            minor = std::stoi(data.substr(0, pos));\n            major = std::stoi(data.substr(pos + 1));\n        }\n    }\n\n    void write(std::ostream& os) const {\n        os << minor << "." << major;\n    }\nprivate:\n    int minor;\n    int major;\n};\n')),(0,i.kt)("p",null,"And that\u2019s it. Now all we have to do is registering the header to the registry system:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Header::Registry::registerHeader<XProtocolVersion>();\n")),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Header instantation")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"You should always provide a default constructor for your header so that it can be instantiated by the registry system"))),(0,i.kt)("p",null,"Now, the ",(0,i.kt)("inlineCode",{parentName:"p"},"XProtocolVersion")," can be retrieved and added like any other header in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Header::Collection")," class."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Unknown headers")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Headers that are not known to the registry system are stored as a raw pair of strings in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection")," class. ",(0,i.kt)("inlineCode",{parentName:"p"},"getRaw()")," can be used to retrieve a raw header:"),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'auto myHeader = request.headers().getRaw("x-raw-header");\nmyHeader.name() // x-raw-header\nmyHeader.value() // returns the value of the header as a string\n')))),(0,i.kt)("h2",{id:"mime-types"},"MIME types"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Media_type"},"MIME Types")," (or Media Type) are also fully typed. Such types are for example used in an HTTP request or response to describe the data contained in the body of the message (",(0,i.kt)("inlineCode",{parentName:"p"},"Content-Type")," header, \u2026) and are composed of a ",(0,i.kt)("em",{parentName:"p"},"type"),", ",(0,i.kt)("em",{parentName:"p"},"subtype"),", and optional ",(0,i.kt)("em",{parentName:"p"},"suffix")," and parameters."),(0,i.kt)("p",null,"MIME Types are represented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Mime::MediaType")," class, implemented in the ",(0,i.kt)("inlineCode",{parentName:"p"},"mime.h")," header. A MIME type can be directly constructed from a string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'auto mime = Http::Mime::MediaType::fromString("application/json");\n')),(0,i.kt)("p",null,"However, to enforce type-safety, common types are all represented as enumerations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Http::Mime::MediaType m1(Http::Mime::Type::Application, Http::Mime::Subtype::Json);\n")),(0,i.kt)("p",null,"To avoid such a typing pain, a ",(0,i.kt)("inlineCode",{parentName:"p"},"MIME")," macro is also provided:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"auto m1 = MIME(Application, Json);\n")),(0,i.kt)("p",null,"For suffix MIMEs, use the special ",(0,i.kt)("inlineCode",{parentName:"p"},"MIME3")," macro:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"auto m1 = MIME3(Application, Json, Zip);\n")),(0,i.kt)("p",null,"If you like typing, you can also use the long form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Http::Mime::MediaType m1(Http::Mime::Type::Application, Http::Mime::Subtype::Json, Http::Mime::Suffix::Zip);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"toString()")," function can be used to get the string representation of a given MIME type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"auto m1 = MIME(Text, Html);\nm1.toString(); // text/html\n")))}m.isMDXComponent=!0}}]);